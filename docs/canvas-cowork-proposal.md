背景：Lovart 做的是一个图像视频 Agent，用户可以让 Agent 生图/视频


**Canvas FS - 从 Agent 视角来看，它只是工作在一个文件夹中**

- **文件和画布是双向映射的，人操作画布，Agent 操作文件**
- 人查看和操作 ↔ 画布上的语义元素 ↔ Agent 的文件夹 ↔ Agent 读写
- Agent 的计划，一个 Mermaid Flowchart，是特殊的元素，Agent 通过 CreatePlan 制作出来，呈现在画布

> **Canvas FS 解锁的具体能力**：
> 
> 
> 
> | 能力 | 没有 Canvas | 有 Canvas |
> | --- | --- | --- |
> | 设计 brief | 聊天里说一嘴就过去了 | [brief.md](http://brief.md/) 文件，agent 和用户都能编辑，始终可见 |
> | 参考素材 | 用户发张图就沉到聊天记录里 | refs/ 文件夹，agent 收集整理，随时可查 |
> | 生图 prompt | agent 内部传参，用户看不到 | prompt.txt 文件，用户可以直接看和改 |
> | 多方案对比 | 在聊天里一张张翻 | 画布上并排摆放，空间对比 |
> | 风格偏好 | 每次重新告诉 agent | MEMORY/ 持久化，跨会话生效 |
> | 复杂项目 | 做不了，聊天流无法承载 | Flow 规划 + 画布呈现，逐步执行 |
> | 修改迭代 | prompt 在 agent 内部复制粘贴，越改越丢 | 文件上 diff 编辑，改了什么一目了然 |
> - Cursor 是 IDE 里嵌了一个 AI 聊天（主体是 IDE）
> - Claude Code 是终端里的 AI（主体是文件系统）
> - 新 Lovart 应该是画布里的 AI（主体是画布）

具体来说：基于 tldraw 构建画布，将空间画布抽象为文件系统供 Agent 操作。

💡

### 元素与映射

- **文本** → `name.txt`
- **图片** → `name.png`
- **方框 (frame)** → 文件夹 `/name/`，互斥，元素只能属于一个方框，这样只有整体只有一层级，不能无限嵌套
- **箭头** → 连接关系，两端必须附着元素才有语义
- **画笔** → 见下方规则

### 图片的双视图

当图片上存在任何箭头或画笔标注时，Agent 获得两张图：**原图**和**标注图**（用户所见的截图样子，含箭头、画笔涂画）。无标注的图片只提供原图。

### 语义边界

- 图片图层上的箭头/画笔 → **有语义**，体现在标注图中
- 其他游离箭头/画笔 → **无语义**，不进入 FS 视野
- 其他视觉能力（移动画布元素的坐标、获取无语义元素的视觉输入）不是 Agent 的主链路

### 配套工具，Agent 的手

**画布语义快照，Snapshot**

输出目录结构 + 连接关系，默认隐藏坐标，可选参数开启。

```
/
├── 背景/
│   ├── 山景.png ✏️
│   └── 说明.txt
├── 参考图.png
└── 备注.txt

Arrows:
  参考图.png (0.25, 0.10) → 背景/山景.png

```

`✏️` 表示该图片存在标注，Agent 可请求标注图查看。

**标准文件系统操作：写入、删除、重命名、移动**

所有在 fs 上的文件操作，（增、删、移动文件、重命名文件）就相当于操作画布上的语义元素

比如将文件从一个文件夹移动到另一个文件夹，就是自动在画布上将一个图片从一个框移动到另一个框中

**文本工具，直接编辑修改文本文件**

这部分 Coding Agent 已经有非常多实践了，Agent 模型也被训练得非常成熟

**图像工具，直接对图片文件执行**

这部分是差异化的点，当前所有二次编辑 Agent 理应能自己触发

但是其实可以作为 Bash 中的 CLI，这样可以组合执行，而不是 Agent 自己多次顺序制定

**兜底的其他视觉语义**

1. Agent 可调用 `Screenshot` 工具获取整个画布截图，捕获所有无语义标注的视觉上下文（或者不提供给主 Agent）
2. 主 Agent 不操作位置关系，不真的在画布上画图，但有可以一个专门的子 Agent 来操作画布（低优先级），
    
    用来完成“帮我整理这个画布排列” “把这个”这种需求
    
